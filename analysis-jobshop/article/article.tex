\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage[ruled]{algorithm2e}
\usepackage{mathabx}
\usepackage{hyperref}
\begin{document}
\title{Análise de algoritmos guloso e dinâmico para resolução de problemas de escalonamento job-shop}
\author{Ewerton Carlos de Araújo Assis}

\maketitle

\begin{abstract}
O presente trabalho, que comporá nota parcial na disciplina de Análise e Projeto de Algoritmos, ministrada pelo professor Leonardo Alves, no Instituto de Informática da Universidade Federal de Goiás, tem como objetivo apresentar soluções algorítmicas para problemas de escalonamento job-shop e a análise destas soluções em termos de sua complexidade computacional (complexidade de tempo). O presente trabalho não tem como finalidade correlacionar ou estabelecer a qualidade das soluções apresentadas --- as quais foram obtidas em literatura especializada ---, muito menos estabelecer a corretude das mesmas.
\end{abstract}

\section{Introdução}
Problemas de escalonamento job-shop, como serão apresentados e definidos a seguir, é uma classe de problemas numericamente intratáveis, NP-difícil \cite{French1982}, que têm, portanto, várias heurísticas e metaheurísticas para solucioná-lo. Dentre elas, são apresentadas duas heurísticas comumente utilizadas para solucionar problemas difíceis na computação: algoritmos gulosos e algoritmos dinâmicos. Como não é intenção do presente trabalho realizar uma análise abrangente de todos os algoritmos que utilizam essas abordagens, dois algoritmos são apresentados: um algoritmo baseado em programação dinâmica \cite{Gromicho2009}; e um algoritmo baseado em estratégia gulosa, construído a partir de outras soluções para problemas de escalonamento. Ambas as estratégias serão definidas e apresentadas, com suas respectivas complexidades computacionais.

O presente trabalho divide-se, portanto, em: definição do que se trata um problema de escalonamento job-shop (seção \ref{definitionJS}); como é constituída uma solução baseada em programação dinâmica (seção \ref{dynamic}); como é constituída uma solução baseada em estratégia gulosa (seção \ref{greedy}); e, por fim, como estas duas abordagens influenciam positivamente para a obtenção de uma solução para um problema NP-difícil (seção \ref{endJS}).

\section{Definição do problema de escalonamento job-shop}
\label{definitionJS}
De forma simples, um problema de escalonamento job-shop pode ser definido como: ``dadas $n$ tarefas (ou \textit{jobs}) $ \{ J_{1}, J_{2}, ..., J_{n} \} $ a serem processadas por $m$ m\'{a}quinas $ \{ M_{1}, M_{2}, ..., M_{m} \} $, cada tarefa deve ser processada por cada m\'{a}quina uma \'{u}nica vez. O processamanto de uma tarefa em uma m\'{a}quina \'{e} denominado opera\c{c}\~{a}o: a opera\c{c}\~{a}o da tarefa $i$ na m\'{a}quina $j$ \'{e} denotada por $o_{ij}$. Restri\c{c}\~{o}es tecnol\'{o}gicas determinam a ordem de processamento de cada tarefa atrav\'{e}s das $m$ m\'{a}quinas. As tarefas em um problema de escalonamento job-shop n\~{a}o compartilham uma mesma ordem de processamento atrav\'{e}s das m\'{a}quinas, (...). O ambiente analisado em um problema de escalonamento job-shop \'{e} geralmente denotado por oficina (\textit{workshop}).

``Cada tarefa $i$  ($J_{i}$) apresenta um tempo de processamento para cada m\'{a}quina, i.e. para cada opera\c{c}\~{a}o $o_{ij}$, opera\c{c}\~{a}o da tarefa $i$ na m\'{a}quina $j$, h\'{a} um tempo de processamento $p_{ij}$. Qualquer tempo de ajuste ou de carregamento (\textit{set-up time}) da m\'{a}quina para processar a opera\c{c}\~{a}o $o_{ij}$ \'{e} inclu\'{i}do em $p_{ij}$. Al\'{e}m do tempo de processamento para cada opera\c{c}\~{a}o, cada tarefa $i$ ($J_{i}$) pode apresentar um tempo de lan\c{c}amento, denotado por $r_{i}$, que determina a partir de quanto tempo ou em qual momento a tarefa $J_{i}$ estar\'{a} dispon\'{i}vel para processamento pelas $m$ m\'{a}quinas da oficina.

``A partir dessas restri\c{c}\~{o}es e defini\c{c}\~{o}es surge a necessidade de construir um escalonador de tarefas de forma a agendar as $n$ tarefas atrav\'{e}s das $m$ m\'{a}quinas de forma que o tempo total de processamento seja o menor poss\'{i}vel. (...).

``O problema de escalonamento job-shop \'{e} considerado um problema numericamente intrat\'{a}vel, NP-dif\'{i}cil (para $m \geq 2$) \cite{French1982} e que apresenta um limite superior de $(n!)^{m}$ solu\c{c}\~{o}es poss\'{i}veis; portanto, objetivamente, a enumera\c{c}\~{a}o de todas as solu\c{c}\~{o}es poss\'{i}veis para inst\^{a}ncias com dimens\~{a}o relevante (por exemplo, $10 \times 15$ ou 10 tarefas, 15 m\'{a}quinas) \'{e} impratic\'{a}vel \cite{Rondon2009}.'' (Definição integralmente apresentada em \cite{Assis2011})

\section{Solução baseada em programação dinâmica}
\label{dynamic}
Uma solução baseada em programação dinâmica pode ser definida rudemente como ``solução recursiva apoiada por uma tabela de subsoluções''. Uma instância do problema é subdividida em várias subinstâncias menores, que são resolvidas, e a partir da combinação das soluções menores, uma solução geral para a instância original é conquistada. Como é geralmente feito o uso de uma tabela para estabelecer a solução das subinstâncias e da instância original, a complexidade da solução relaciona-se ao tamanho da tabela construída.

Soluções em programação dinâmica são, a partir dessa constatação inicial, inerentemente recursivas: o problema deve ser modelado como um problema recursivo, no qual a solução de dada instância depende da solução de subinstâncias menores da instância original. Soluções baseadas em programação dinâmica têm como complexidade fórmulas de recorrência, dada essa característica recursiva.

Como o problema é modelado a partir de uma abordagem recursiva, com o fim de evitar que subinstâncias sejam resolvidas mais de uma vez, a solução baseada em programação dinâmica toma como apoio uma tabela, que armazena as soluções conquistadas para as subinstâncias tratadas nas iterações (recurções) do algoritmo.

\subsection{Algoritmo dinâmico para problemas de escalonamento job-shop}
O algoritmo dinâmico análisado para solucionar problemas de escalonamento job-shop tem por base o algoritmo apresentado em ``Exponentially better than brute force: solving the job-shop scheduling problem optimally by dynamic programming.'', que não foi copiado aqui dado a complexidade de definições que são apresentadas no artigo. Seja $p_{max} =$ max$_{ij}p_{ij}$, o algoritmo apresentado tem como complexidade $\mathcal{O}((2p_{max})^{n-1}(n\sqrt{n} + (2p_{max})^{2})(m + 1)^{n}n)$.

A ideia básica na construção da solução, que tem por objetivo criar uma agenda que tenha um tempo de execução mínimo, mas não ótimo, a partir das ideias de Held and Karp para problemas de sequenciamento, apresentada no artigo ``\emph{A dynamic programming approach to sequencing problems}''. A ideia, então, é criar uma sequência de operações a partir de definições, teoremas e corolários feitos a partir da descrição do problema de escalonamento job-shop.

\section{Solução baseada em estratégia gulosa}
\label{greedy}
Uma solução baseada em estratégia gulosa parte como princípio um problema que foi modelado recursivamente: uma instância do problema é resolvida a partir da solução de subinstâncias da instância original. Assim, a cada iteração (ou recurção, propriamente dito) o algoritmo escolhe como subsolução aquela que for mais interessante em dada iteração --- gula, nesse contexto, relaciona-se à ganância pela melhor solução em dado momento.

Diferentemente da abordagem baseada em programação dinâmica (seção \ref{dynamic}), que mantém um panorama geral das subinstâncias que já foram conquistadas e resolvidas e que influenciam na obtenção da solução da instância original, na abordagem gulosa não existe um panorama geral: decisões são tomadas em microcontextos; no caso, na iteração corrente. Assim, existe um comportamento cego e de ``\emph{(micro)-}exploração'' no espaço de busca da solução --- \emph{exploitation} ---, antagônico a ``\emph{(macro)-}exploração'' --- \emph{exploration}.

\subsection{Algoritmo guloso para problemas de escalonamento job-shop}
A seguir é apresentada uma solução baseada em estratégia gulosa para problemas de escalonamento job-shop. A intenção do presente algoritmo é construir uma agenda que seja factível; contudo, nenhum compromisso com critérios de otimalidade é estabelecido. Em seguida é feita uma análise de complexidade de tempo do algoritmo.

\begin{algorithm}
\DontPrintSemicolon
\textbf{Entrada}: Instância de problema com $n$ tarefas e $m$ máquinas\;
\textbf{Assuma}: $\Omega :$ \{ $(o_{ij}, p_{ij})$, t.q. $o_{ij}$ é a operação da tarefa $i$ na máquina $j$ e $p_{ij}$ é o tempo de processamento da tarefa $i$ na máquina $j$\}\;
\textbf{Saída}: Sequência $T$, uma tupla com a ordem de operações a serem realizadas no \emph{workshop}\;\;
\Begin{
\While{$ |\Omega| > 0$}{
  $o' \leftarrow$ Retira $(o_{ij}, p_{ij}) \in \Omega$, com $p_{ij}$ mínimo do conjunto\;
  Adiciona o elemento $o_{ij}$ da tupla $o'$ na tupla $T$\;
}
\textbf{return} $T$\;
}
\caption{Estratégia gulosa: solução para escalonamento job-shop\label{algo}}
\end{algorithm}

\subsection{Análise do algoritmo guloso}
Como o tamanho do conjunto $\Omega = n \times m$, temos que a complexidade desse algoritmo é $\mathcal{O}(nm)$. Nenhuma garantia quanto à otimalidade da solução é assumida; o único intuito é obter uma agenda de execução das tarefas que tem por base uma estretégia gulosa.

Se fosse aplicado o método de força bruta para obter uma solução ótima a partir da análise de todas as sequências criadas por esse algoritmo, essa solução teria complexidade de tempo na ordem de $\mathcal{O}(nm + n!^{m})$, dado que o número de soluções possíveis para esse problema está na ordem de $n!^{m}$ soluções \cite{Assis2011}.

\section{Conclusão}
\label{endJS}
As soluções apresentadas têm como propósito elucidar como soluções algorítmicas baseadas em abordagem gulosa e em programação dinâmica devem orientar-se, a partir de um cenário-problema apresentado: problemas de escalonamento job-shop.

Ambas as abordagens e soluções apresentadas têm como propósito resolver um problema de escalonamento NP-difícil, no qual soluções triviais, por força bruta, não são interessantes. A solução gulosa, diferentemente da solução dinâmica, tem como propósito construir uma agenda que seja possível e interessante como solução, embora não exista qualquer compromisso de que a solução-agenda encontrada seja de fato ótima (a otimalidade da solução não é garantida nem intencionada). Já a solução dinâmica tenta inferir a partir de subsoluções uma solução-agenda que seja interessante e relativamente próxima ao critério de otimalidade.

As abordagens apresentadas são interessantes em cada contexto analisado: se for interessante obter ao menos uma solução-agenda para o problema, que não tenha compromisso com otimalidade, a solução gulosa é apropriada nesse contexto. No entanto, quando uma solução ótima é almejada, uma solução baseada em programação dinâmica poderá ser obtida; ou mesmo poderá ser feito o uso de outras abordagens para obter uma solução \cite{Assis2011}.

\bibliographystyle{inf-ufg}
\bibliography{bibliograph}
\end{document}
